#!/bin/sh

set -u

say() {
    echo "multirustproxy: $1"
}

err() {
    say "$1" >&2
    exit 1
}

need_cmd() {
    if ! command -v $1 > /dev/null 2>&1
    then err "need $1"
    fi
}

need_ok() {
    if [ $? != 0 ]; then err "$1"; fi
}

assert_nz() {
    if [ -z "$1" ]; then err "assert_nz $2"; fi
}

call_multirust() {
    assert_nz "$multirust_cmd" "multirust"
    "$multirust_cmd" "$@"
}

need_cmd dirname
need_cmd basename

# Environment sanity checks
if [ -z "${0-}" ]; then err "arg 0 is undefined"; fi

cmd_dirname=$(dirname "$0")
cmd_basename=$(basename "$0")
multirust_cmd="$cmd_dirname/multirust"

push_sysroot_ldpath() {
    _sysroot="$1"
    assert_nz "$_sysroot" "sysroot"

    _new_path="$_sysroot/lib"

    OLD_LD_LIBRARY_PATH="${LD_LIBRARY_PATH-}"
    LD_LIBRARY_PATH="$_new_path:${LD_LIBRARY_PATH-}"
    export LD_LIBRARY_PATH

    OLD_DYLD_LIBRARY_PATH="${DYLD_LIBRARY_PATH-}"
    DYLD_LIBRARY_PATH="$_new_path:${DYLD_LIBRARY_PATH-}"
    export DYLD_LIBRARY_PATH
}

pop_sysroot_ldpath() {
    LD_LIBRARY_PATH="$OLD_LD_LIBRARY_PATH"
    export LD_LIBRARY_PATH
    DYLD_LIBRARY_PATH="$OLD_DYLD_LIBRARY_PATH"
    export DYLD_LIBRARY_PATH
}

# Check if multirust exists
if [ ! -e "$multirust_cmd" ]; then
    err "can't find multirust"
fi

# Figure out what mode we're in
case "$cmd_basename" in
    rustc | rustdoc | cargo | rust-lldb | rust-gdb )
	rust_cmd="$cmd_basename"
	;;
    multirustproxy)
	err "I should not be run manually"
	;;
    *)
	err "unable to interpret command name"
	;;
esac

extra_flags=
case "$rust_cmd" in
    rustc )
	# Sneak rpaths into all compilation so dylibs work
	extra_flags="-C rpath"
	;;
esac

# If this is a recursive multirust call then don't check for
# updates to avoid lots of redundant notices. Issue #16.
disable_updates="${MULTIRUST_ENGAGED-}"
for arg in "$@"; do
    case "$arg" in
	--version | -V )
	    # If user requests the version then we don't want
	    # multirust to inject its own output since the version
	    # number is often parsed.
	    disable_updates=true
	    ;;
	--print | --print=* )
	    # If special output is requested, do not disrupt the
	    # output with update messages.
	    disable_updates=true
	    ;;
    esac
done

# Verbose output would break the following ctl commands
unset MULTIRUST_VERBOSE

# Get the home directory, just to reexport it later
multirust_home="${MULTIRUST_HOME-}"
if [ -z "$multirust_home" ]; then
    multirust_home="$(call_multirust ctl home)"
    need_ok '`multirust ctl home` failed'
    assert_nz "$multirust_home" "multirust_home is empty"
fi

# Get the override toolchain
toolchain="${MULTIRUST_TOOLCHAIN-}"
if [ -z "$toolchain" ]; then
    toolchain="$(call_multirust ctl override-toolchain)"
    need_ok '`multirust ctl override-toolchain` failed'
    assert_nz "$toolchain" "toolchain is empty"
fi

# Get the sysroot for the override toolchain
sysroot="$(call_multirust ctl toolchain-sysroot "$toolchain")"
need_ok '`multirust ctl toolchain-sysroot` failed'
assert_nz "$sysroot" "sysroot is empty"

lib_path="$sysroot/lib"

# Exports needed to make everything work

# Find the libraries we need
LD_LIBRARY_PATH="$lib_path:${LD_LIBRARY_PATH-}"
DYLD_LIBRARY_PATH="$lib_path:${DYLD_LIBRARY_PATH-}"

# Isolate cargo
CARGO_HOME="$sysroot/cargo"

# Tell recursive toolchain invocations which toolchain we're using
# (Cargo will seemingly change directories into its own home dir)
MULTIRUST_TOOLCHAIN="$toolchain"

# As above, just preserve this for cases when $HOME gets moved
# somewhere crazy (Cargo's test suite does this...)
MULTIRUST_HOME="$multirust_home"

# This is just a flag for detecting recursion
MULTIRUST_ENGAGED=true

export LD_LIBRARY_PATH
export DYLD_LIBRARY_PATH
export CARGO_HOME
export MULTIRUST_TOOLCHAIN
export MULTIRUST_HOME
export MULTIRUST_ENGAGED

exec "$sysroot/bin/$rust_cmd" $extra_flags "$@"
